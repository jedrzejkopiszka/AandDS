# Algorithms and Data Structures 
The repository contains notebooks prepared by me for Algorithms and Data Structures classes

## Sorting algorithms comparison
**Algorithms used**: Bubble sort, Heap Sort, Counting sort, Shell sort, Merge sort, Quicksort
<br><br>
**Time complexity measured for:**
1. Sorting of randomly generated integers according to the uniform distribution.
1. Sorting effectiveness for QS, HS, MS for data generated using:
    * uniform distribution
    * constant value 
    * increasing order
    * descending order
    * A-shaped data
    * V-shaped data
  
## Data structures comparison
**Structures used**: ordered list, Binary Search Tree (BST), AVL tree
<br><br>
**TIme complexity measured for:**
1. Insertion of a single element
2. Removal of all elements (one by one, the element being removed chosen randomly)

## Graph algorithms
**Graph representation used**: neighborhood matrix, incident matrix, edge list, list of incidents
<br><br>
**Algorithms used:** topological order sorting
<br><br>
**TIme complexity measured for:** 
1. For randomly generated undirected graph measure the time of obtaining information about the existence of edges between a pair of random vertices.
2. For randomly generated directed acyclic graph use topological sorting procedure


## Backtracking 
**Algorithms used:** finding Eulerian cycle, finding hamiltonian cycle in undirected graphs
<br><br>
**TIme complexity measured for:** 
1. For randomly generated connected graph find Eulerian cycle. Compare times for different edge saturations (0.2, 0.3, 0.4, 0.6, 0.8, 0.95
2. For randomly generated connected graph find Hamiltonian cycle. Compare times for different edge saturations (0.2, 0.3, 0.4, 0.6, 0.8, 0.95)


## Dynamic programming - Knapsack problem
**Algorithm used to solve (or approximate) Knapsack problem**: brute force, greedy algorithm, dynamic algorithm
<br><br>
**TIme complexity measured for:** 
1. comparison of brute force, greedy algorithm, the dynamic algorithm for samples of Knapsack problem with different number of elements
2. comparison of the greedy algorithm (approximation) and algorithm using dynamic programming. 

